\documentclass[jou,apacite]{IEEEtran}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{tabu}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{relsize}
\usepackage[font=footnotesize]{subfig}
\usepackage{hyperref}
\usepackage{minted}
\setminted{fontsize=\small, breaklines=true}

\usepackage{graphicx}
\graphicspath{ {../images/} }
\setlength\parindent{0pt}

\title{Scala - A Powerful and Scalable Function-Objective Programming Language}

\author{Troy Hu and Benjamin Killeen} % alphabetical by last name

\begin{document}
\maketitle    

\begin{abstract}
Insert abstract here.
\end{abstract}                     

\section{Introduction}
\label{sec:intro}

Software components are simply self-contained parts of software used by larger
parts or entire applications. Modern software typically relies on many common
components like hashable types or iterable data structures to use as building
blocks. Component abstraction enables the generalization of implementation for
these features, greatly reducing duplication of effort. It is one of the most
powerful tools in the programmer's utility belt, a fact which the designers of
the Scala programming language aimed to exploit \cite{odersky2004overview}. In
the early 2000s, existing languages had little support for type-sound component
abstraction, including widely used languages like Java and C\#. Odersky \emph{et
  al.} address this shortcoming with a language that combines elements of
object-oriented and functional programming in a statically typed
environment. Scala, which gets its name from ``scalable,'' provides a powerful
interface for abstraction within a development framework intended for mass
adoption.

In pursuit of usability, Scala borrows many syntactic elements from Java and
C\#, and it integrates smoothly with components from these languages. In fact,
the Scala library includes standard Java objects like \texttt{java.lang.String},
as shown in Listing~\ref{lst:print}. Scala code can take advantage of existing
implementations in Java, and in the end it compiles to Java bytecode, making
Scala packages available to Java programmers. At the same time, Scala maintains
a distinct programming paradigm from either Java or C\#. It discards some
features from these languages, and it develops completely novel ideas from the
$\nu$Obj calculus \cite{odersky_nominal_2003}. The example in
Listing~\ref{lst:print} highlights syntactic similarities between Java and Scala,
comparing two implementations of the same program. Note how Java prepends type
declarations before terms, whereas Scala affixes type declarations using the
\texttt{:} operator. This and other changes effect a terser, more expressive
syntax overall.

\begin{listing}
  \centering
  \inputminted[frame=single]{Java}{../examples/PrintExample.java}
  \inputminted[frame=single]{Scala}{../examples/PrintExample.scala}
  \caption{Notice how Scala's general syntax and structure are similar
    to Java's. At the same time, there are some visible differences, e.g., unit
    is returned in the Scala implementation instead of void in the Java
    implementation.}
  \label{lst:print}
\end{listing}

Of course, Scala's foremost strength comes from its typing system. Abstract
class definitions and path-dependent types utilize the $\nu$Obj Calculus,
enabling incredible flexibility through the use of traits and mixins
\cite{odersky_nominal_2003}. Somewhat akin to Java's abstract classes, traits
allow a programmer to rely on abstract methods for common functionalities. For
example, the \texttt{Equiv[T]} trait in Fig.~\ref{lst:equiv} represents an
equivalence relation on the type \texttt{T}, abstracting the definition of
\texttt{eq} on which a concrete method, \texttt{neq} depends. Mixins enable a
class to inherit from multiple traits. For instance, one might use
\texttt{Equiv} in conjunction with an \texttt{Ordering} trait to represent
separate relations on the same type in one object.

Finally, the uniform object model in Scala provides a cohesive programming
environment. Every Scala value is an object, and every operation is a call to a
method. The boolean \texttt{true}, for example, is a singleton object that
extends (inherits from) the Boolean trait (see
Sec.~\ref{sec:singleton-objects}). At the same time, Scala fits into a
functional programming paradigm. Functions themselves are values, and the syntax
allows for SML-like decomposition and pattern matching. These features result in
a powerful language with a unified programming experience.

% 3. related work
\section{Related Work}
\label{sec:related-work}

\begin{figure*}[h]
  \centering
  \includegraphics[width=0.9\linewidth]{scala_classes}
  \caption{A visual representation of Scala's class hierarchy}
  \label{fig:scala-classes}
\end{figure*} 

The ideas underlying Scala come from a variety of work. First and foremost, the
designers rely on the $\nu$Obj calculus outlined in Odersky \emph{et al.}
(2003) for a theoretical grounding on which they build Scala's robust type
system \cite{odersky_nominal_2003}. Although a thorough discussion of the
$\nu$Obj calculus is beyond the scope of this paper, which focuses on the Scala
language proper, we describe its main points in brief. Additionally, the ideas
in Scala have been replicated or expanded on in more recent work, which we
discuss here.

The $\nu$Obj calculus is, broadly, a calculus and dependent type system that
includes classes and objects with types as members
\cite{odersky_nominal_2003}. \emph{Dependent types} rely on some value for
definition, and with this formalism, the $\nu$Obj calculus expresses Java's
inner class system, virtual types, and family polymorphism. Furthermore, it
models SML-style modules and functors, diverging from standard object-oriented
type systems in three fundamental ways:
\begin{enumerate}
\item Objects \emph{and} classes are considered primitive, as opposed to just
  objects.
\item Type checking and evaluation rely on name references rather than object
  records.                     %TODO: check with Troy.
\item Object types are expressible using possibly nominal type components.
\end{enumerate}
These alterations make possible the rigorous blend of object-oriented and
functional styles evident in Scala, differing markedly from traditional
languages like Java and C\#.

% TODO: talk about more related work, including Rust language, more recent
% extensions of Scala's systems.
% TODO: CITE
The Rust programming language is a popular alternative to Scala that is
designed to target systems-level applications. The 
language is similar to C++ in that it allows users to interact directly 
with hardware. Moreover, the syntax of Rust is very similar to that of C++. 
Rust, however, is unlike C++ in that any program purely written
in Rust is guaranteed to avoid memory errors and data races.
Most notably, Rust utilizes many of Scala's core concepts to achieve its goals.
Like Scala, Rust is both a functional and object-oriented programming language
(to model C++). Rust also ensures type soundness in order to avoid memory errors
such as dangling pointers. Unlike Scala, however, Rust emphasizes 
concurrency and paralellism.

The remainder of this paper focuses on the practical considerations of
programming in the Scala language.

\section{Programming in Scala}
\label{sec:programming-scala}

Being a fully developed programming language, Scala implements numerous useful
features that encourage modularity and reusability in software. In this section,
we highlight just a few of these, as well as provide an overview of the general
process through which software construction takes place in Scala.

\subsection{Unified Object Model}
\label{sec:unified-object-model}

In Scala, every value is an object and every class is a subtype of the
\texttt{Any} class. Fig.~\ref{fig:scala-classes} shows an overview of the
unified object model in Scala's standard library, under which many classes
simply absorb the existing Java implementation. Immutable objects or
\emph{values}, denoted with the \texttt{val} keyword on declaration, inherit
from the class \texttt{AnyVal}, and include classes like \texttt{scala.Boolean}
and \texttt{scala.Char}. Mutable \emph{variables} on the other hand, inherit
from \texttt{scala.AnyRef}, which is synonymous with the generic
\texttt{java.lang.Object}. These include classes like \texttt{scala.List} or
traits like \texttt{scala.Ordered}. Even functions fit into this object model,
such as the \texttt{scala.Function1} trait, which single-argument functions
implement.

One of the fundamental aspects of Scala is its invariance with respect to value
representation. Under this rule, \emph{interpreting an value belonging to some
  subclass as an element of its superclass does not change that value's
  representation.} Put another way, this invariance rule demands that for types
\texttt{S}, \texttt{T} with \texttt{S~<:~T}, and \texttt{x} of type \texttt{S},
\begin{minted}{Scala}
x.asInstanceOf[T].asInstanceOf[S] = x
\end{minted}
always holds. Because of this rule, Scala's object model includes some unusual
relations not found in more traditional languages. In particular,
Fig.~\ref{fig:scala-classes} uses dashed lines to denote a \emph{View} from one
type to another. As discussed in Sec.~\ref{sec:views}, a view enables
interpretation between types which are not strictly subtypes of one another. For
example, both \texttt{Int} and \texttt{Float} maintain a member called
\texttt{MaxValue}, which other function can rely on without requiring a strict
subtype of either \texttt{Int} or \texttt{Float}. Finally, the
\texttt{scala.Nothing} trait is a subtype of every other class, allowing for
flexible objects like the \texttt{scala.List} object \texttt{Nil}, of type
\texttt{List[Nothing]}.

Another fundamental feature of Scala's object model inclusion of operations,
which are invocations of a method. For example, the usual addition operator
\texttt{+} can be implemented like any other method, as in
Lst.~\ref{lst:nats-example}, and invoked in the exact same way: \texttt{x.+(y)}.
Of course Scala allows for the more conventional calling style \texttt{x + y},
but it does so merely through syntactic sugaring. Here, \texttt{x} is the
receiver object, \texttt{+} is a method defined in \texttt{x}, and \texttt{y} is
the method's argument.

Finally, Scala differs from Java with regard to the construction of
objects. Rather than define a dedicated constructor function within objects, the
class name itself is simply the constructor. Object instantiations simply runs
the entire body of the class, instantiated member variables, values, and
definitions.

\subsection{Traits, Objects, and Classes}
\label{sec:traits-obj-cls}

Traits in Scala are somewhat akin to abstract classes in Java, defining abstract
members that should be implemented by more concrete classes. As a very simple
example, consider the \texttt{Nat} trait which defines necessary operations on
natural numbers: %
\begin{samepage}
  \inputminted{Scala}{../examples/ExampleNat.scala} %
\end{samepage}

Classes which inherit from \texttt{Nat} must implement the \texttt{isZero},
\texttt{succ}, and \texttt{pred} methods with the corresponding types in order
to inherit from \texttt{Nat}. This is advantageous for several reasons. First,
as we shall see, the \texttt{Nat} class may use these abstract methods to define
more complex functions, which subclasses need not implement. Second, other
functions may refer to \texttt{Nat}s as a whole rather than either subclass of
the original trait.

Objects or singleton objects in Scala often accompany trait definitions. A
singleton object is at the same time a class definition and the sole
instantiated member of that class. For instance, the \texttt{Z} object
represents the natural number ``zero,'' of which there can only be one: %
\begin{samepage}
  \inputminted{Scala}{../examples/ExampleZero.scala} %
\end{samepage}
This simple implementation behaves as we would expect, relying on the \texttt{S}
class (below) to implement \texttt{Z.succ}. The choice to ensure \texttt{Z.pred
  = Z} was made in keeping with conventional evaluation rules. The use of the
\texttt{extends} keyword represents the inheritance from \texttt{Nat}.

Similarly classes in Scala can ``extend'' a trait, while taking in arguments to
the constructor. The \texttt{S} class %
\begin{samepage}
  \inputminted{Scala}{../examples/ExampleSucc.scala} %
\end{samepage}
represents the ``successor'' of another natural \texttt{n}, either \texttt{Z} or
another \texttt{S}. Here, the use of the \texttt{case} keyword results in a
constructor very similar to constructors in SML, which can be instantiated
without the use of \texttt{new} and easily deconstructed in pattern matching
blocks.

\subsection{Views}
\label{sec:views}

In place of loose subtyping, Scala requires views to implicitly convert objects
from one type to another. A view is implemented with a method that takes in an
arguemnt of one type and returns an object of another type. The only difference
between a view method and a normal method is that view methods require the
\texttt{implicit} modifier, which goes before the method definition. This
modifier allows the Scala compiler to know that it is the implcit conversion
method when converting from one type to another. Scala implictly applies a view
to an expression, $e$ of type $T$, when one of the following cases occur:
\begin{itemize}
\item The expected type of $e$ is not of type $T$.
\item A member selected from $e$ is not a member of $T$.
\end{itemize}  
For example, in Lst.~\ref{lst:set-example}, \texttt{listToSet} is the view that converts \texttt{GenList[T]} to \texttt{Set[T]}. The compiler inserts applications of the view onto \texttt{xs}.

\begin{listing}
  \inputminted[frame=single, firstline=3, lastline=14]{Scala}{../examples/Set.scala}
  \caption{An example of views and implcit conversions.}
  \label{lst:set-example}
\end{listing}

\subsection{Pattern Matching in an Object-Oriented Setting}
Unlike Java and other object-oriented programming languages, Scala implements
pattern matching. That is, Scala provides the programmer with a natural and
functional-like mechanism for ``creating structured data representations similar
to algebraic data types and a decomposition mechanism based on pattern
matching.''

Since Scala is an object-oriented programming language, it does not have
algebraic data types. Instead, Scala creates structured data representations
through the \texttt{\textbf{case}} modifier. If $\textbf{case}$ precedes the
definition of a class, a factory method with the same arguments as the primary
class constructor is automatically defined. For example, in Figure 4, since the
\texttt{\textbf{Num}} and \texttt{\textbf{Plus}} classes are defined with the
\texttt{\textbf{case}} modifier, we can define an “anonymous” \textbf{Num}
object without using the \textbf{new} keyword. As the reader can see, factory
methods are very similar in structure to the constructors of algebraic data
types. In fact, factory methods serve the same purpose as constructors when
pattern matching.

Scala's pattern matching expressions can decompose the factory method
constructors as patterns. The syntax for pattern matching expressions is
\begin{minted}[escapeinside=||, mathescape=true]{Scala}
x match { 
  case |$p_1$| => |$e_1$|
  case |$p_2$| => |$e_2$|
  |$\dots$|
}
\end{minted}
where $p_1$, $p_2$ are patterns compared against \texttt{x} in order, and $e_1$,
$e_2$ are the resulting expressions. Each $p_i$ is of the form
$\mathtt{FactoryMethod}(x_1, x_2, …, x_n)$, where \texttt{FactoryMethod} refers
to the factory method constructors discussed previously. When a match $p_i$ is
found, then $e_i$ is executed. For example, in Figure 5, the \texttt{eval}
function matches \texttt{term} against \texttt{Num(x)} and \texttt{Plus(left,
  right)} (the constructors are from Figure 4).

\begin{figure}[h]
  \centering
  \includegraphics[width=\columnwidth]{abstract_class}
  \caption{example}
  \label{fig:example}
\end{figure}

\begin{figure}[h]
  \centering
  \includegraphics[width=\columnwidth]{pattern_match}
  \caption{}
  \label{fig:example}
\end{figure}

Note: unlike Java, writing a simple language interpreter in Scala is almost as easy as writing an interpreter in SML. Examples of pattern matching being used for an interpreter can be seen in the calculator program we wrote.

\begin{listing}
  \inputminted[firstline=3, frame=single]{Scala}{../examples/Equiv.scala}
  \caption{A simple equivalence relation Scala.}
  \label{lst:equiv}
\end{listing}

\begin{listing}
  \inputminted[firstline=3, frame=single]{Scala}{../examples/Ord.scala}
  \caption{An ordering relation in Scala. It is important to distinguish between
    an ordered type and an ordering on that type, of which there can be
    arbitrarily many. \texttt{Ordering[T]} represents the latter.}
  \label{lst:ordering}
\end{listing}

% Abstraction: -NOT DONE
% - subtypes and polymorphism
% - Traits and classes.
%   - A trait do encapsulate state. They just define methods or variables that you
%     have to have but don't provide instantiated values for those.
%   -Classes require implementations or values for everything.

% Multiple inheritance with mixins. (Small paragraph right after abstractions) -NOT DONE

% Views in Scala implement something close to SML's signatures or Haskell's
% typeclasses. -DONE

\begin{listing}
  \inputminted[frame=single]{Scala}{../examples/Nat.scala}
  \caption{An example outlining Scala classes.}
  \label{lst:nats-example}
\end{listing}

% 4. report on peano arithmetic calculator.
\section{Engagement: Peano Arithmetic Calculator}
\label{sec:engag-peano-arithm}

% 5. should encapsulate discussion of current status
\section{Discussion}
\label{sec:discussion}

\subsection{Current Status of Work}
After 15 years, Scala has been regularly updated and is currently at stable
release version 2.12.8. Over this period, the core principles of Scala have
remained the same. Scala has achieved widespread adoption in the industry with
companies such as Twitter and Apple utilizing the language. Moreover, Scala has
both a large academic and non-academic user base. The language is often cited or
used in computer science research. In addition, Scala's user community is
thriving. there exist chatrooms, subreddits, and research conferences devoted
entirely to Scala. Numerous libraries, tutorials, and guides are run and
maintained by the community. The main community page can be found at:
https://www.scala-lang.org/community/. A detailed, updated, and easy to read
documentation can be found at: https://docs.scala-lang.org/. Finally, there are
dedicated installers/installation guides for all operating systems at:
\href{https://www.scala-lang.org/download/}{scala-lang.org/download}.


\bibliographystyle{IEEEtran}
\bibliography{scala_project}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% TeX-command-extra-options: "-shell-escape"
%%% End:
